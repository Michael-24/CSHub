## 数据库



### 关系型和非关系型数据库的区别（各自优点）



### 常用SQL语句（DDL,DML,DCL,TCL）



### 数据库中join的类型与区别（inner join, outer join, cross join, natural join, self join）

- 内连接（Inner Join）：仅将两个表中满足连接条件的行组合起来作为结果集
  - 自然连接：只考虑属性相同的元组对；
  - 等值连接：给定条件进行查询
- 外连接（Outer Join）
  - 左连接：左边表的所有数据都有显示出来，右边的表数据只显示共同有的那部分，没有对应的部分补NULL；
  - 右连接：和左连接相反；
  - 全外连接（Full Outer Join）：查询出左表和右表所有数据，但是去除两表的重复数据
- 交叉连接（Cross Join）：返回两表的笛卡尔积（对于所含数据分别为m、n的表，返回m*n的结果）

### 数据库查询语句执行过程

1. 客户端发送一条查询给服务端。
2. 服务端在查询缓存中查询是否有缓存。如果有缓存（之前执行过此语句），通过权限验证后直接返回结果。如果没有缓存，则进入分析器。
3. 服务器进行SQL的解析与预处理，再有优化器生成对应的执行计划。
4. 服务器根据执行计划调用存储引擎借口执行操作。

### 数据库的索引类型

逻辑分类：

* 主键索引：每张表只有一个，当定义主键时会自动创建一个主键索引。主键索引中的每个值都是唯一的，不能有重复值，同时不能有空值。
* 唯一索引：索引中的每个值都是唯一的，不能有重复值，但是可以有空值。
* 普通索引：索引中的每个值可以重复，也可以有空值。

物理分类：

* 聚簇索引：数据和索引一同存储，数据在物理存储中的顺序跟索引中数据的逻辑顺序相同，一般是表中的主键索引，如果没有主键索引就会以第一个非空的唯一索引作为聚集索引。一张表只能有一个聚集索引。
* 非聚簇索引：数据在物理上的存储顺序和索引中的顺序不同。非聚集索引的叶子节点除了保存索引键值以外，同时叶子结点的索引行中保存了对应索引行的主键。在查找的过程中，如果需要获得找到的索引行的其他字段，需要利用已经保存的主键执行回表操作。

联合索引：联合索引是建立在表上多个列的索引。联合索引的内部实现也是一棵B+树，不同的是联合索引内部键的数量大于等于2，其中键值都是排序的，通过叶子结点可以逻辑上顺序读出所有的数据，联合索引的数据对于所有的索引列都是排好序的。联合索引的使用遵循最左匹配原则。

### 聚集索引和非聚集索引的区别

聚集索引按照每张表的主键构建一课B+树，同时在叶子结点中存放的数据就是整张表的完整行记录数据，内部的索引也存放索引键以及指向数据页的偏移量。索引的叶子节点就是数据页。每张表只有一个聚集索引。聚集索引的所有数据的排列顺序是按照主键大小排列的。

使用聚集索引，可以在索引的数据页上直接找到数据，并且针对范围查询速度特别块。并且，针对主键的范围查找以及排序操作也特别快。聚集索引中数据排列顺序有序指的是逻辑上有序，通过双向链表组织，不一定在物理存储上连续。

非聚集索引和聚集索引的区别在于，非聚集索引的叶子节点除了保存索引键值以外，同时叶子结点的索引行中保存了对应索引行的主键。在查找的过程中，如果需要获得找到的索引行的其他字段，需要利用已经保存的主键执行回表操作。

### 索引的优缺点，什么时候使用索引，什么时候不能使用索引

**索引的优点**

1. 大大减少了扫描数据库的数据量。
2. 帮助服务器避免排序和生成临时表。
3. 将随机I/O变成顺序I/O。

**索引的缺点**

1. 创建索引和维护索引都需要一定的时间消耗，数据量越多时间消耗越明显。
2. 索引需要占用一定的存储空间。
3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度。

**索引的使用时机**

当使用索引带来的好处超过了使用索引带来的额外工作时，使用索引是有好处的。

例如，当一个表很小时，使用索引未必有使用全表扫描高效；如果一个表是一个中到大型的表，那么使用索引就很高效；如果一个表是个特大型的表，那么建立索引的的额外工作会很高，一般会采用分表的方式。

**什么时候索引是有效的**

* 全值匹配。
* 匹配最左前缀。
* 

**什么时候索引会失效**

* 以“%(表示任意0个或多个字符)”开头的LIKE语句。
* OR语句前后没有同时使用索引。
* 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）。
* 对于多列索引，必须满足最左匹配原则/最左前缀原则。
* 如果MySQL估计全表扫描比索引快，则不使用索引。

### 高效的索引策略

**独立的列**

索引列不能是表达式的一部分，也不能是函数的参数，因为这些情况会导致索引失效。

**选择合适的索引列顺序**

由于B-树索引的最左匹配原则，索引的查询顺序是首先按照最左的索引列进行排序，然后按照第二左的索引列进行排序，以此类推。

选择合适的索引列顺序有一个经验法则，将选择性强的索引列放在前面。索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。

**前缀索引**

对于 BLOB、TEXT 和很长的VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符，因为MySQL不允许索引这些列的完整长度。

前缀的长度根据索引选择性来确定，前缀索引需要足够长保证有足够的选择性，同时也不能太长耗费空间。

**多列索引**

在需要使用多个索引列的时候，一个多列索引会比多个单列索引的性能要好。

MySQL可以使用索引合并利用多个单列索引定位需要的行，但是存在几个问题：

* 如果索引合并执行大量的AND操作，说明需要建立一个多列索引。
* 如果索引合并执行大量的OR操作，会耗费大量的系统资源。
* 查询优化器无法评估这些开销。

因此，如果需要在多个列上同时使用索引，最好建立一个多列索引，并且优化查询的顺序。

**覆盖索引**

覆盖索引指的是查找的所有内容都落在了索引页面上。覆盖索引有以下的好处：

* 索引数目通常小于数据行的数目，可以减少数据的访问量，并且更容易放进内存中。
* 索引按照值的大小排序存取，可以把随机I/O转换为顺序I/O。
* 有些引擎在内存中缓存索引，数据依靠操作系统的系统调用，可以减少系统调用的次数。
* 对于InnoDB，可以避免二级索引查询后对主键索引的回表操作。

### 索引的底层实现

InnoDB引擎中，索引的底层实现采用的是B+-树。B+-树是一种平衡二叉树，专门针对磁盘进行了优化。

**为何不采用红黑树**

红黑树也是一种平衡树，红黑树是一种二叉树，父节点只有两个子节点。数据库应用的数据规模都很大，超出内存的容量也很正常，在这种情况下，平衡二叉查找树性能不佳，因为平衡二叉查找树树高较高，需要多次随机的磁盘访问，I/O开销很大。

磁盘还有一种特性，那就是顺序访问的时间和随机I/O的时间相比区别不大，因此对于数据库中的平衡树，利用磁盘更适合顺序访问的特性，一次大批量访问磁盘，可以提升性能。

因此需要把二叉搜索树改造为多路搜索树，大部分数据库的索引都是基于B+-树实现的。B+-树的高度更低，需要执行磁盘I/O的次数更少。并且B+-树的所有节点按照顺序存储在磁盘上，可以利用磁盘的预读特性，一次读取更多的键，减少I/O次数。

### B-树和B+-树的区别

B-树和B+-树的区别：

* 分支结点的构造不同：B+-树每个键对应的数据项必须保存在叶子结点中，因此内部节点的键值会有重复。B-树中每个键值只出现一次，内部节点也可以保存键对应的数据值，因此内部节点会多保存一个指针指向内部键对应的数据值。
* 查询过程不同：B树在找到具体的数值以后，则结束。而B+树则需要通过索引找到叶子结点中的数据才结束。

B+树的优点在于，由于B+树的数据都存储在叶子结点中，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，如果要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况。

B树的优点在于，如果仅仅执行单个数据值的查找，那么它需要访问的平均页面数量要比B+树少，并且相比于哈希索引，执行范围查询需要的时间更少。

所以通常B+树用于数据库索引，而B树则常用于文件索引。

### 索引最左匹配原则

使用联合索引的时候，查询语句必须从索引的最左列开始匹配。如果没有从最左边开始匹配，就不能使用这个联合索引。同时，如果查询语句在索引的某个列上执行了范围查找，这个列右边的列都不能使用索引。

### MySQL索引类型

MySQL主要有三种索引类型：B+-树索引，哈希索引，全文索引。

#### B+-树索引

是大多数 MySQL 存储引擎的默认索引类型。

因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。

因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。

可以指定多个列作为索引列，多个索引列共同组成键。

适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。

#### 哈希索引

哈希索引能以 O(1) 时间进行查找，时间非常快，但是失去了有序性：

- 无法用于排序与分组；
- 只支持精确查找，无法用于部分查找和范围查找。

InnoDB支持自适应哈希索引，对于某些使用次数非常频繁的索引值，会在内存中创建一个哈希索引，使得B+-树索引也具有哈希索引的一些优点，比如快速的哈希查找。这个过程是自动的行为，用户无法控制。

#### 全文索引

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。

全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。

InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。

### MySQL的优化（高频，索引优化，性能优化）



### 数据库引擎介绍，Innodb和Myisam的特点与区别

MySQL使用最为广泛的存储引擎是InnoDB和MyISAM。

#### InnoDB

是 MySQL 默认的事务型存储引擎。

实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。

对于表中的数据，主索引是聚簇索引，在索引中保存了数据，数据的存储按照主键的顺序存放。

内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

#### MySIAM

设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

提供了大量的特性，包括压缩表、空间数据索引等。

不支持事务。

不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。

可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，执行表的修复可能导致一些数据丢失，而且修复操作是非常慢的。

如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。

#### InnoDB和MyISAM的区别

* 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
* 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
* 外键：InnoDB 支持外键。
* 备份：InnoDB 支持在线热备份。
* 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
* 其它特性：MyISAM 支持压缩表和空间数据索引。

#### 如何选择存储引擎

除非需要用到某些InnoDB不具备的特性，并且没有其他方法可以替代，都则都是推荐使用InnoDB存储引擎。如果需要InnoDB不支持的特性时，才会考虑其他引擎。

### 数据库中事务的ACID特性（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）

事务是一组原子的SQL查询或者一组工作单元，事务中的语句要么全部执行成功，要么全部执行失败。

**A：原子性（atomicity）**

原子性指的是整个数据库事务是一个不可分割的单位，所有的操作全部执行成功才能视为事务执行成功，如果有任何一个操作失败了，数据库需要回滚到事务开始执行之前的状态。

**C：一致性（consistency）**

一致性要求在事务开始和事务结束后数据库的完整性约束不能被破坏。

**I：隔离性（isolation）**

隔离性要求事务对数据库对象的读写对其他事物是不可见的，只有这个事务提交了其他事务才能看到看到读写。

**D：持久性（duration）**

事务一旦提交，其结果就是永久性的，即使发生宕机也能够恢复。但是如果数据库外部发生了故障，那么可能所有的提交都会丢失。

### 数据库隔离性设置不同会出现的问题

* 脏读：不同的事务下，当前事务可以读到其他事务没有提交的数据。

* 不可重复读：一个事务内多次读取同一个范围的数据，在当前事务还没有结束时，另一个事务也访问了同一段数据集合，并做了一些DML操作。第一个事务的两次查询会有不一致的情况。

* 幻读：一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。

  > 这种问题在当前读情况下才会出现。普通的一致性非锁定读是快照读，加锁的方式是当前读。

* 丢失更新：一个事务的更新会导致另一个事务的更新被覆盖，造成不一致的现象。如果这种情况主要出现在基于数据库的应用编写过程中。

### 事务的隔离级别

在关系型数据库中，事务的隔离级别分为以下四种：读未提交、读提交、可重复读、串荇化。

* 读未提交：在这个隔离级别下，一个事务的修改，即使没有被提交，也能被其他的事务看到。
* 读提交：在这个隔离级别下，所有事务只能看到已提交事务做的修改。可以解决脏读问题。**Oracle的默认隔离级别是读提交**。
* 可重复读：在这个隔离级别下，保证了在一个事务中多次读取同样的记录结果是一直的。可以解决脏读和不可重复读问题。**MySQL的默认隔离级别是可重复读**。在InnoDB存储引擎中，通过MVCC机制可以解决该隔离级别下的幻读问题。
* 串行化：在这个隔离级别下，事务强制串行执行，保证了一致性。可以解决所有的问题。由于会给事务读取的每一行加锁，可能会导致大量的锁争用。在InnoDB存储引擎中，串行化主要用于分布式事务。

### MVCC

MVCC实现了非阻塞的读操作，在很多情况下避免了加锁操作。MVCC为每一个事务保存了一个Read View，根据这个Read View，不同的事务对于同一个表会看到不同版本的数据。

InnoDB存储引擎通过undo log保存每一行的多个版本记录，每个undo log都带有事务ID，事务ID是递增的。在Read View中，保存了当前活跃的（启动了但是还没有提交）事务ID，数组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加 1 记为高水位。

在执行非锁定读（普通的select）过程中，根据以下原则判断一条记录是否可读：

1. 如果记录的事务id小于低水位，那么这个事务已经提交，可以读取。
2. 如果记录的事务id大于高水位，那么这个事务在生成Read View时还没有开始运行，不能读取。
3. 否则，根据活跃事务ID数组判断。如果事务ID不在活跃数组中，说明已经提交，可以读取记录；否则，事务还在运行，不能读取记录。

如果执行其他修改数据库的命令时，操作方法如下：

* insert：InnoDB为新插入的一行保存当前事务ID作为行版本号。
* delete：InnoDB为被删除的行保存当前事务ID作为行删除标志。
* update：InnoDB为被更新的行保存当前事务ID作为行版本号，并且保存当前事务ID作为行删除标志。

读提交隔离级别的Read View在查询语句启动前生成。可重复读的Read View在事务启动前生成。其他的隔离级别和MVCC不兼容。读未提交每次都是读取最新行，不需要快照机制，而串行化对所有的读取都会加锁。

### 快照读和当前读

在可重复读的隔离级别下，普通的select语句就是快照读，读取的是快照的数据，不需要加锁的操作。

```sql
SELECT * FROM table ...;
```

其他会对数据库修改的操作（insert、update、delete）需要进行加锁操作，读取最新的数据。这种情况称为当前读。如果对于select语句执行显式加锁操作，执行的也是当前读。

区分快照读和当前读，避免了普通的select需要加锁的操作，提升了并发读的效率。

### Mysql的表空间方式，各自特点

表空间是InnoDB存储引擎逻辑结构的最高层。所有数据都存放在表空间下。

* 共享表空间：数据库所有的表文件、索引文件全部放在同一个表空间。
* 独立表空间：每张表中的数据都可以单独放在一个表空间下。然而，其他信息（回滚信息，插入缓冲索引页，系统事务信息，二次写缓冲）还是放在原来的共享表空间中。

### 数据库的范式

* **第一范式(确保每列保持原子性)**：第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。

* **第二范式(确保表中的每列都和主键相关)**：在满足第一范式的前提下，（主要针对联合主键而言）第二范式需要确保数据库表中的每一列都和主键的所有成员直接相关，由整个主键才能唯一确定，而不能只与主键的某一部分相关或者不相关。 

* **第三范式(确保非主键的列没有传递依赖)**：在满足第二范式的前提下，第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。非主键的列不能确定其他列，列与列之间不能出现传递依赖。

* **BCNF范式（确保主键之间没有传递依赖**：主键有可能是由多个属性组合成的复合主键，那么多个主键之间不能有传递依赖。也就是复合主键之间谁也不能决定谁，相互之间没有关系。

### 锁的种类，加锁的方式

锁的种类分为两种：共享锁和排他锁。

* 共享锁（S Lock）：允许事务读一行数据。
* 排他锁（X Lock）：允许事务删除或者更新一行数据。

共享锁和排他锁的兼容性见下表。

|      |   S    |   X    |
| :--: | :----: | :----: |
|  X   | 不兼容 | 不兼容 |
|  S   |  兼容  | 不兼容 |

同时，InnoDB还支持意向两种锁：意向共享锁和意向排他锁，用于支持多粒度锁。如果要对最细粒度的对象加锁，那么首先要对粗粒度对象加锁，如果其中任何一个部分导致等待，必须等待粗粒度锁的释放。

* 意向共享锁（IS Lock）：事务想要获得表中某几行的共享锁。
* 意向排他锁（IX Lock）：事务想要获得表中某几行的排他锁。

数据库的加锁有以下两个规定：

- 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

共享性见下表。

|      |   IS   |   IX   |   S    |   X    |
| :--: | :----: | :----: | :----: | :----: |
|  IS  |  兼容  |  兼容  |  兼容  | 不兼容 |
|  IX  |  兼容  |  兼容  | 不兼容 | 不兼容 |
|  S   |  兼容  | 不兼容 |  兼容  | 不兼容 |
|  X   | 不兼容 | 不兼容 | 不兼容 | 不兼容 |

MySQL锁粒度分为两种：行级锁和表级锁。

使用更小粒度的锁：

* 优势：锁定的记录更少，产生锁争用的可能性更小，并发度更高。
* 劣势：系统开销更大（获得锁、检查锁是否被解除、释放锁都需要耗费资源）。

显式加锁语句

```sql
SELECT ... LOCK In SHARE MODE;
SELECT ... FOR UPDATE;
```

### 两阶段锁协议

在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。

如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放，能够提升并发度。

### InnoDB行锁算法

InnoDB实现了三种行锁算法：

* Record Lock：锁住一条特定的记录。
* Gap Lock：锁住一个范围，但是不锁定记录本身。
* Next-Key Lock：Gap Lock+Record Lock，锁定一个范围，并锁定记录本身。

**Next-Key Lock总是锁住索引记录，如果表没有指定索引，那么InnoDB就会使用隐式的主键锁定记录。**

在默认隔离级别（可重复读）下，InnoDB对于行的查询使用的都是Next-Key Lock，设计的目的为解决幻读问题。存在一个特例，如果在唯一索引上执行等值查询，Next-Key Lock会退化为Record Lock。

### 乐观锁和悲观锁

* 悲观锁的设计思路如下：如果一个事务执行的过程中可能存在冲突，那么直接放弃，等待直到绝对安全后继续执行。适用于更新非常频繁的场景。
* 乐观锁的设计思路如下：如果可能发生前在的冲突，事务会继续执行而不是终止，寄希望于一切相安无事。当提交的时候，检查是否确实发生了冲突，如果发生了冲突，终止事务并重试。使用于读多写少的场景。

