## 数据库



### 关系型和非关系型数据库的区别（各自优点）



### 常用SQL语句（DDL,DML,DCL,TCL）



### 数据库中join的类型与区别（inner join, outer join, cross join, natural join, self join），注意适用场景和sql语句的编写



### 数据库查询语句执行过程

1. 客户端发送一条查询给服务端。
2. 服务端在查询缓存中查询是否有缓存。如果有缓存（之前执行过此语句），通过全县验证后直接返回结果。如果没有缓存，则进入分析器。
3. 服务器进行SQL的解析与预处理，再有优化器生成对应的执行计划。
4. 服务器根据执行计划调用存储引擎借口执行操作。

### 数据库的索引类型

逻辑分类：

* 主键索引：每张表只有一个，当定义主键时会自动创建一个主键索引。主键索引中的每个值都是唯一的，不能有重复值，同时不能有空值。
* 唯一索引：索引中的每个值都是唯一的，不能有重复值，但是可以有空值。
* 普通索引：索引中的每个值可以重复，也可以有空值。

物理分类：

* 聚簇索引：数据和索引一同存储，数据在物理存储中的顺序跟索引中数据的逻辑顺序相同，一般是表中的主键索引，如果没有主键索引就会以第一个非空的唯一索引作为聚集索引。一张表只能有一个聚集索引。
* 非聚簇索引：数据在物理上的存储顺序和索引中的顺序不同。非聚集索引的叶子节点除了保存索引键值以外，同时叶子结点的索引行中保存了对应索引行的主键。在查找的过程中，如果需要获得找到的索引行的其他字段，需要利用已经保存的主键执行回表操作。

### 聚集索引和非聚集索引的区别

聚集索引按照每张表的主键构建一课B+树，同时在叶子节点中存放的数据就是整张表的行记录数据，索引的叶子节点就是数据页。每张表只有一个聚集索引。

非聚集索引和聚集索引的区别在于，非聚集索引的叶子节点除了保存索引键值以外，同时叶子结点的索引行中保存了对应索引行的主键。在查找的过程中，如果需要获得找到的索引行的其他字段，需要利用已经保存的主键执行回表操作。

### 索引的优缺点，什么时候使用索引，什么时候不能使用索引

**索引的优点**

1. 大大减少了扫描数据库的数据量。
2. 帮助服务器避免排序和生成临时表。
3. 将随机I/O变成顺序I/O。

**索引的缺点**

1. 创建索引和维护索引都需要一定的时间消耗，数据量越多时间消耗越明显。
2. 索引需要占用一定的存储空间。
3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度。

**索引的使用时机**

当使用索引带来的好处超过了使用索引带来的额外工作时，使用索引是有好处的。

例如，当一个表很小时，使用索引未必有使用全表扫描高效；如果一个表是一个中到大型的表，那么使用索引就很高效；如果一个表是个特大型的表，那么建立索引的的额外工作会很高，一般会采用分表的方式。

### 高效的索引策略



### 索引的底层实现

InnoDB引擎中，索引的底层实现采用的是B+树。B+-树是一种平衡二叉树，专门针对磁盘进行了优化。

**为何不采用红黑树**

红黑树也是一种平衡树，为了保持平衡性，需要经常执行节点的旋转操作。



### B-树和B+-树的区别







### 索引最左匹配原则

使用联合索引的时候，查询语句必须从索引的最左列开始匹配。如果没有从最左边开始匹配，就不能使用这个联合索引。同时，如果查询语句在索引的某个列上执行了范围查找，这个列右边的列都不能使用索引。

### Mysql的优化（高频，索引优化，性能优化）



### 数据库引擎介绍，Innodb和Myisam的特点与区别



**如何选择存储引擎**

除非需要用到某些InnoDB不具备的特性，并且没有其他方法可以替代，都则都是推荐使用InnoDB存储引擎。如果不需要

### 数据库中事务的ACID特性（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）

事务是一组原子的SQL查询或者一组工作单元，事务中的语句要么全部执行成功，要么全部执行失败。

**A：原子性（atomicity）**

原子性指的是整个数据库事务是一个不可分割的单位，所有的操作全部执行成功才能视为事务执行成功，如果有任何一个操作失败了，数据库需要回滚到事务开始执行之前的状态。

**C：一致性（consistency）**

一致性要求在事务开始和事务结束后数据库的完整性约束不能被破坏。

**I：隔离性（isolation）**

隔离性要求事务对数据库对象的读写对其他事物是不可见的，只有这个事务提交了其他事务才能看到看到读写。

**D：持久性（duration）**

事务一旦提交，其结果就是永久性的，即使发生宕机也能够恢复。但是如果数据库外部发生了故障，那么可能所有的提交都会丢失。

### 数据库隔离性设置不同会出现的问题

* 脏读：不同的事务下，当前事务可以读到其他事务没有提交的数据。

* 不可重复读：一个事务内多次读取同一个范围的数据，在当前事务还没有结束时，另一个事务也访问了同一段数据集合，并做了一些DML操作。第一个事务的两次查询会有不一致的情况。

* 幻读：一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。

  > 这种问题在当前读情况下才会出现。

* 丢失更新：一个事务的更新会导致另一个事务的更新被覆盖，造成不一致的现象。这种情况主要出现在基于数据库的应用编写过程中。

### 事务的隔离级别

在关系型数据库中，事务的隔离级别分为以下四种：读未提交、读提交、可重复读、串荇化。

* 读未提交：在这个隔离级别下，一个事务的修改，即使没有被提交，也能被其他的事务看到。
* 读提交：在这个隔离级别下，所有事务只能看到已提交事务做的修改。可以解决脏读问题。**Oracle的默认隔离级别是读提交**。
* 可重复读：在这个隔离级别下，保证了在一个事务中多次读取同样的记录结果是一直的。可以解决脏读和不可重复读问题。**MySQL的默认隔离级别是可重复读**。在InnoDB存储引擎中，通过MVCC机制可以解决该隔离级别下的幻读问题。
* 串行化：在这个隔离级别下，事务强制串行执行，保证了一致性。可以解决所有的问题。由于会给事务读取的每一行加锁，可能会导致大量的锁争用。在InnoDB存储引擎中，串行化主要用于分布式事务。

### MVCC

MVCC实现了非阻塞的读操作，在很多情况下避免了加锁操作。MVCC为每一个事务保存了一个Read View，根据这个Read View，不同的事务对于同一个表会看到不同版本的数据。

InnoDB存储引擎通过undo log保存每一行的多个版本记录，每个undo log都带有事务ID，事务ID是递增的。在Read View中，保存了当前活跃的（启动了但是还没有提交）事务ID，数组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加 1 记为高水位。

在执行非锁定读过程中，根据以下原则判断一条记录是否可读：

1. 如果记录的事务id小于低水位，那么这个事务已经提交，可以读取。
2. 如果记录的事务id大于高水位，那么这个事务在生成Read View时还没有开始运行，不能读取。
3. 否则，根据活跃事务ID数组判断。如果事务ID不在活跃数组中，说明已经提交，可以读取记录；否则，事务还在运行，不能读取记录。

读提交隔离级别的Read View在查询语句启动前生成。可重复读的Read View在事务启动前生成。

### 事务的实现

事务的ACID可以通过redo log和undo log保证。

* redo log用于保证事务的持久性。
* undo log用于MVCC的实现以及保证事务的原子性。

redo结构



undo结构



### Mysql的表空间方式，各自特点

表空间是InnoDB存储引擎逻辑结构的最高层。所有数据都存放在表空间下。

* 共享表空间：数据库所有的表文件、索引文件全部放在同一个表空间。
* 独立表空间：每张表中的数据都可以单独放在一个表空间下。然而，其他信息（回滚信息，插入缓冲索引页，系统事务信息，二次写缓冲）还是放在原来的共享表空间中。

### 数据库的范式

* **第一范式(确保每列保持原子性)**：第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。

* **第二范式(确保表中的每列都和主键相关)**：在满足第一范式的前提下，（主要针对联合主键而言）第二范式需要确保数据库表中的每一列都和主键的所有成员直接相关，由整个主键才能唯一确定，而不能只与主键的某一部分相关或者不相关。 

* **第三范式(确保非主键的列没有传递依赖)**：在满足第二范式的前提下，第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。非主键的列不能确定其他列，列与列之间不能出现传递依赖。

* **BCNF范式（确保主键之间没有传递依赖**：主键有可能是由多个属性组合成的复合主键，那么多个主键之间不能有传递依赖。也就是复合主键之间谁也不能决定谁，相互之间没有关系。

### 锁的种类，加锁的方式





行锁分为两种：共享锁和排他锁。

* 共享锁（S Lock）：允许事务读一行数据。
* 排他锁（X Lock）：允许事务删除或者更新一行数据。

共享锁和排他锁的兼容性见下表。

|      |   S    |   X    |
| :--: | :----: | :----: |
|  X   | 不兼容 | 不兼容 |
|  S   |  兼容  | 不兼容 |

同时，InnoDB还支持意向两种锁：意向共享锁和意向排他锁，用于支持多粒度锁。如果要对最细粒度的对象加锁，那么首先要对粗粒度对象加锁，如果其中任何一个部分导致等待，必须等待粗粒度锁的释放。

* 意向共享锁（IS Lock）：事务想要获得表中某几行的共享锁。
* 意向排他锁（IX Lock）：事务想要获得表中某几行的排他锁。

数据库的加锁有以下两个规定：

- 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

共享性见下表。

|      |   IS   |   IX   |   S    |   X    |
| :--: | :----: | :----: | :----: | :----: |
|  IS  |  兼容  |  兼容  |  兼容  | 不兼容 |
|  IX  |  兼容  |  兼容  | 不兼容 | 不兼容 |
|  S   |  兼容  | 不兼容 |  兼容  | 不兼容 |
|  X   | 不兼容 | 不兼容 | 不兼容 | 不兼容 |

加锁语句

```sql
SELECT ... LOCK In SHARE MODE;
SELECT ... FOR UPDATE;
```

### 两阶段锁协议

在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。

如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放，能够提升并发度。

### InnoDB行锁算法

InnoDB实现了三种行锁算法：

* Record Lock：锁住一条特定的记录。
* Gap Lock：锁住一个范围，但是不锁定记录本身。
* Next-Key Lock：Gap Lock+Record Lock，锁定一个范围，并锁定记录本身。

**Record Lock总是锁住索引记录，如果表没有指定索引，那么InnoDB就会使用隐式的主键锁定记录。**

在默认隔离级别（可重复读）下，InnoDB对于行的查询使用的都是Next-Key Lock，设计的目的为解决幻读问题。存在一个特例，如果在唯一索引上执行等值查询，Next-Key Lock会退化为Record Lock。

### 乐观锁和悲观锁

悲观锁

