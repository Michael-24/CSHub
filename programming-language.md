## 语言基础（C/C++/Golang）



### 指针和引用的区别



### 堆和栈的区别



new和delete是如何实现的，new与malloc的异同处



C和C++的区别

C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）

Struct和class的区别

define和const的区别（编译阶段、安全性、内存占用等）

在C++中const和static的用法（定义，用途）

const和static在类中使用的注意事项（定义、初始化和使用）

C++中的const类成员函数（用法和意义），以及和非const成员函数的区别

C++的顶层const和底层const

final和override关键字

拷贝初始化和直接初始化，初始化和赋值的区别

extern "C"的用法

模板函数和模板类的特例化

C++的STL源码（这个系列也很重要，建议侯捷老师的**STL源码剖析**书籍与视频），其中包括内存池机制，各种容器的底层实现机制，算法的实现原理等）

### STL源码中的hashtable的实现



STL中unordered_map和map的区别和应用场景

STL中vector的实现

STL容器的几种迭代器以及对应的容器（输入迭代器，输出迭代器，前向迭代器，双向迭代器，随机访问迭代器）

> 顺序容器：vector,deque是随机访问迭代器；list是双向迭代器
>
> 容器适配器：stack,queue,priority_queue没有迭代器
>
> 关联容器：set,map,multiset,multimap是双向迭代器
>
> unordered_set,unordered_map,unordered_multiset,unordered_multimap是前向迭代器

STL中的traits技法

> type_traits
>
> iterator_traits
>
> char traits
>
> allocator_traits
>
> pointer_traits
>
> array_traits

vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。

C++中的重载和重写的区别

C++内存管理，内存池技术（热门问题），与csapp中几种内存分配方式对比学习加深理解

介绍面向对象的三大特性，并且举例说明每一个

C++多态的实现

C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（包括单一继承，多重继承等）（拓展问题：为什么基类指针指向派生类对象时可以调用派生类成员函数，基类的虚函数存放在内存的什么区，虚函数表指针vptr的初始化时间）

C++中类的数据成员和成员函数内存分布情况

this指针

析构函数一般写成虚函数的原因

### 构造函数、拷贝构造函数和赋值操作符的区别

* 构造函数：对象不存在，没用别的对象初始化
* 拷贝构造函数：对象不存在，用别的对象初始化
* 赋值运算符：对象存在，用别的对象给它赋值

### 构造函数声明为explicit

用于构造函数只有一个参数的情况。这个关键字要求

### 构造函数为什么一般不定义为虚函数



### 构造函数的几种关键字(default delete 0)

* =default：将拷贝控制成员定义为=default显式要求编译器生成合成的版本

* =delete：将拷贝构造函数和拷贝赋值运算符定义删除的函数，阻止拷贝（析构函数不能是删除的函数 C++Primer P450）
* =0：将虚函数定义为纯虚函数（纯虚函数无需定义，=0只能出现在类内部虚函数的声明语句处；当然，也可以为纯虚函数提供定义，不过函数体必须定义在类的外部）

### 构造函数或者析构函数中调用虚函数会怎样

在继承体系中，首先调用基类的构造函数，然后调用子类的构造函数。继承类的虚函数表指针在调用继承类的构造函数时初始化。如果在在基类的构造函数中执行虚函数，虚函数执行的版本是基类实现的版本，而不是继承类实现的版本。

析构函数同理，继承类的虚函数表指针在继承类析构过程中指向基类的虚函数表。此时如果在基类的析构函数中调用虚函数，执行的一定会是基类实现的版本。

### 纯虚函数

纯虚函数是只有定义没有实现的函数，

如果一个类声明了纯虚函数，那么这个类就是一个虚基类，这个类不能被实例化，只有继承了这个类的子类可以实例化。



### 静态类型和动态类型，静态绑定和动态绑定的介绍



### 引用是否能实现动态绑定，为什么引用可以实现



深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）

对象复用的了解，零拷贝的了解



### 介绍C++所有的构造函数



### 什么情况下会调用拷贝构造函数（三种情况）

* 对象以值传递的方式传入函数参数。
* 对象以值方式从返回值返回。
* 对象通过另一个同类型对象初始化。

### 结构体内存对齐方式，为什么要进行内存对齐？

字节对齐的作用是提高系统的性能。如果一个数据没有对齐，那么需要更多的内存读取次数。

字节对齐遵循的原则是，任何K字节的基本对象的起始地址必须是K的倍数。如果在结构体中，需要在字段中插入间隙，保证每个字段都能满足对齐要求。另外，结构体的末尾也有可能需要填充字符，保证在数据中，每个元素满足对齐要求。

### 内存泄露的定义，如何检测与避免？



### 手写智能指针的实现（shared_ptr和weak_ptr实现的区别）



### 智能指针的循环引用



### 遇到coredump要怎么调试

coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。

通常使用gdb调试

```shell
gdb [可执行文件名称] [core文件名称]
```

### 内存检查工具的了解

### 模板的用法与适用场景

### 成员初始化列表



**为什么用成员初始化列表会快一些（性能优势）？**

使用成员初始化列表执行的是直接初始化的操作，而



用过C++ 11吗，知道C++ 11哪些新特性？

C++的调用惯例（简单一点C++函数调用的压栈过程）

C++的四种强制转换

> static_cast
>
> dynamic_cast
>
> const_cast
>
> reinterpret_cast

C++中将临时变量作为返回值的时候的处理过程（栈上的内存分配、拷贝过程）

C++的异常处理

volatile关键字

优化程序的几种方法

### public，protected和private访问权限和继承



### inline和宏定义的区别



### C++和C的类型安全



### C++从源文件到可执行文件的过程

从源文件到目标文件的过程为：预编译、编译、汇编、链接。

* 预处理：根据#字符修改原始程序。
* 编译：生成汇编语言程序。
* 汇编：根据汇编语言程序生成可重定位目标文件。
* 链接：把目标文件链接起来生成可执行目标文件。