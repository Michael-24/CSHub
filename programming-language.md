## 语言基础（C/C++）



### 指针和引用的区别

1. 指针是一种类型，存在自己的地址，可以通过访问这个地址来修改另一个变量；引用仅仅是一个别名，对引用的操作就是对变量的本身进行操作。
2. 指针可以为空，引用不能为空。
3. 指针可以是多级的，引用只有一级，不存在引用的引用。
4. 引用必须初始化，指针可以不用初始化。
5. 引用不能改变目标，指针可以改变目标。

### 堆和栈的区别

* 堆和栈的管理方式不同。栈由操作系统管理分配与释放，而堆需要由程序员手动管理分配与释放，容易造成内存泄漏等问题。
* 堆和栈的生长方向不同。栈向下生长，堆向上生长。
* 堆容易产生内存碎片，内存的频繁分配与释放会导致内存空间的不连续。栈内存永远是后进先出，不存在栈内存中间出现不连续的情况。
* 栈内存的分配由专门的指令支持，分配效率高，有专门的寄存器存放栈的地址，压栈出栈都有专门的寄存器支持。堆内存的分配需要C函数库专门提供，比较复杂，因而耗时更高。
* 栈空间的大小是固定的（Linux下是8M），堆空间的大小几乎没有限制。

### new和delete是如何实现的，new与malloc的异同处

new语句的实现有以下几个步骤：

* 调用operator new函数，分配一块足够大的原始的未命名内存空间。
* 在这块内存上调用对应的构造函数生成相应的对象，并返回内存空间的首地址。

delete语句实现有以下几个步骤：

* 调用对应的析构函数销毁对象。
* 调用operator delete函数，释放对应的内存空间。

**new和malloc的不同之处**

* malloc仅仅分配一块内存空间，函数不知道内存空间的大小，需要程序员手动传入分配大小的参数。new不仅分配一块对象大小的内存，还会在这块内存上构造对应的对象。
* 程序可以通过重载operator new操作自定义分配内存的行为，程序可以自行控制分配内存的行为。
* new返回的是对象指针，malloc返回的是void*。
* new失败后会抛出bad_alloc异常，并且可以使用set_new_handler设置new失败时会调用的回调函数。而malloc失败后会返回空指针。

### C和C++的区别



### C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）



### struct和class的区别

1. struct默认成员访问权限是public，class默认成员访问权限是private。
2. struct的继承默认是public继承，class的继承默认是private继承。

### define和const的区别（编译阶段、安全性、内存占用等）

* 编译：
* 安全性：
* 内存占用：

### C++中const的用法



### C++中static的用法

1. 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
2. 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。
3. 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
4. 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。

静态成员函数要访问非静态成员时，要用过对象来引用。局部静态变量在函数调用结束后也不会被回收，会一直在程序内存中，直到该函数再次被调用，它的值还是保持上一次调用结束后的值。

### const和static在类中使用的注意事项（定义、初始化和使用）



### C++中的const类成员函数（用法和意义），以及和非const成员函数的区别



### C++的顶层const和底层const

* 

### final和override关键字

* 如果一个成员函数被final关键字修饰，那么任何尝试覆盖这个函数的操作都会引发错误。
* 如果一个成员函数被override关键字修饰，说明这个函数是派生类中的虚函数。如果派生类标记了一个不是虚函数的成员函数，编译器会报错。

### volatile关键字

volatile用于指示编译器，当前变量指向的内存不是一块不同的内存，不要使用常用的优化手段优化对该对象的访问代码。

> 

### 拷贝初始化和直接初始化，初始化和赋值的区别



### extern "C"的用法

C++在编译的过程中会执行符号修饰操作，用于支持C++的复杂特性，而C则没有。如果C++使用了一个C头文件，那么C++编译出来的符号和C的不同，在链接的过程中会出错。此时extern "C"就起作用了：告诉链接器按照C语言的方式处理括号内的代码。

然而，extern “C”在C语言中是错误语法，因此需要使用C++的宏“__cplusplus”判断当前的编译单元是否是C++代码。

extern “C”的用法如下

```C++
#ifdef __cplusplus
extern "C" {
#endif

void *memset(void *, int, size_t);

#ifdef __cplusplus
}
#endif
```

### C++的STL源码（这个系列也很重要，建议侯捷老师的**STL源码剖析**书籍与视频），其中包括内存池机制，各种容器的底层实现机制，算法的实现原理等

STL主要包含以下几个组件：

* 

### STL源码中的hashtable的实现



**解决哈希冲突的方法**

* 链地址法：把所有哈希值相同的冲突元素保存在同一个链表中。查找的过程中，

### STL中unordered_map和map的区别和应用场景



### STL中vector的实现



### STL容器的几种迭代器以及对应的容器（输入迭代器，输出迭代器，前向迭代器，双向迭代器，随机访问迭代器）

> 顺序容器：vector,deque是随机访问迭代器；list是双向迭代器
>
> 容器适配器：stack,queue,priority_queue没有迭代器
>
> 关联容器：set,map,multiset,multimap是双向迭代器
>
> unordered_set,unordered_map,unordered_multiset,unordered_multimap是前向迭代器

### vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。



### C++中的重载和重写的区别

* 重载：两个函数有着同样的函数名。但是它们要么参数的个数不同，要么参数的类型不同。如果两个参数仅仅返回值不同，编译器无法决定使用哪个函数。
* 重写：
* 覆盖：

### C++内存管理

在SGI STL中，采用两级配置器管理方式：

* 一级配置器：一级配置器是对malloc/free函数的封装，allocate()调用malloc函数，deallocate()调用free函数。
* 二级配置器：如果内存的需求大于128bytes，那么使用第一级配置器；额外维护了16个自由链表，负责16种小型区块的配置能力。这个内存池由malloc分配得来。如果内存不足，转而使用第一级配置器配置足够的空间给第二级配置器，然后再次尝试内存的分配过程。

### 面向对象的三大特性

面向对象的三大特性是：封装，继承和多态。

* 封装隐藏了类的实现细节和成员数据，实现了代码模块化，如类里面的private和public；
* 继承使得子类可以复用父类的成员和方法，实现了代码重用；
* 多态则是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用，如父类的指针指向子类的对象。

### C++多态的实现

静态多态

动态多态

### C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（包括单一继承，多重继承等）（拓展问题：为什么基类指针指向派生类对象时可以调用派生类成员函数，基类的虚函数存放在内存的什么区，虚函数表指针vptr的初始化时间）

#### 虚函数表和虚函数指针



#### 虚函数的实现原理



#### 为什么基类指针指向派生类对象时可以调用派生类成员函数，



#### 基类的虚函数存放在内存的什么区



#### 虚函数表指针vptr的初始化时间



### C++中类的数据成员和成员函数内存分布情况

#### 数据成员分布



#### 成员函数分布





### this指针



### 析构函数一般写成虚函数的原因

如果基类指针指向一个派生类对象，当执行析构过程时，如果基类的析构函数不是虚函数，那么调用的是基类的析构函数，无法正确释放派生类的资源，造成内存泄漏。如果基类的析构函数是一个虚函数，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源。

### 构造函数、拷贝构造函数和赋值操作符的区别

* 构造函数：对象不存在，没用别的对象初始化
* 拷贝构造函数：对象不存在，用别的对象初始化
* 赋值运算符：对象存在，用别的对象给它赋值

### 构造函数声明为explicit

用于构造函数只有一个参数的情况。这个关键字要求

### 构造函数为什么一般不定义为虚函数



### 构造函数的几种关键字(default delete 0)

* =default：将拷贝控制成员定义为=default显式要求编译器生成合成的版本

* =delete：将拷贝构造函数和拷贝赋值运算符定义删除的函数，阻止拷贝（析构函数不能是删除的函数 C++Primer P450）
* =0：将虚函数定义为纯虚函数（纯虚函数无需定义，=0只能出现在类内部虚函数的声明语句处；当然，也可以为纯虚函数提供定义，不过函数体必须定义在类的外部）

### 构造函数或者析构函数中调用虚函数会怎样

在继承体系中，首先调用基类的构造函数，然后调用子类的构造函数。继承类的虚函数表指针在调用继承类的构造函数时初始化。如果在在基类的构造函数中执行虚函数，虚函数执行的版本是基类实现的版本，而不是继承类实现的版本。

析构函数同理，继承类的虚函数表指针在继承类析构过程中指向基类的虚函数表。此时如果在基类的析构函数中调用虚函数，执行的一定会是基类实现的版本。

### 纯虚函数

纯虚函数是只有定义没有实现的函数，

如果一个类声明了纯虚函数，那么这个类就是一个虚基类，这个类不能被实例化，只有继承了这个类的子类可以实例化。

### 静态类型和动态类型，静态绑定和动态绑定的介绍



### 引用是否能实现动态绑定，为什么引用可以实现



### 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）



### 对象复用的了解，零拷贝的了解



### 介绍C++所有的构造函数



### 什么情况下会调用拷贝构造函数（三种情况）

* 对象以值传递的方式传入函数参数。
* 对象以值方式从返回值返回。
* 对象通过另一个同类型对象初始化。

### 结构体内存对齐方式，为什么要进行内存对齐？

字节对齐的作用是提高系统的性能。如果一个数据没有对齐，那么需要更多的内存读取次数。

字节对齐遵循的原则是，任何K字节的基本对象的起始地址必须是K的倍数。如果在结构体中，需要在字段中插入间隙，保证每个字段都能满足对齐要求。另外，结构体的末尾也有可能需要填充字符，保证在数据中，每个元素满足对齐要求。

### 内存泄露的定义，如何检测与避免？

如果程序通过动态内存分配内存空间，使用完毕后没有手动释放，导致内存一直被占用的现象，成为内存泄漏。

造成内存泄漏的原因：

* new/delete没有配套使用。
* 释放数组时没有使用delete[]，仅使用了delete。
* 没有将基类的析构函数定义为虚函数，当基类指针指向派生类对象时，如果积累的析构函数不是虚函数，那么不会调用派生类的虚函数，子累的资源没有正确释放，造成内存泄漏。
* 没有正确释放数据成员的内存。

避免方法：

* 采用RAII类或者智能指针管理动态内存的分配与释放。
* 将基类的析构函数设置为虚函数。

### 智能指针的类型

智能指针一共有四种类型：

* 

### 智能指针的循环引用

如果两个对象分别持有指向对方的shard_ptr，会阻止这两个对象的析构，即使其他的数据结构已经不能访问这两个对象了，他们的引用计数仍然为1。这就发生了内存泄漏事件，这两个对象已经没有用了，但是程序无法回收内存空间。

解决方法是使用weak_ptr，它指向一个对象，但是不增加对象的引用计数。

### 遇到coredump要怎么调试

coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。

通常使用gdb调试

```shell
gdb [可执行文件名称] [core文件名称]
```

### 内存检查工具的了解



### 模板的用法与适用场景



### 成员初始化列表

成员初始化列表就是在类或者结构体的构造函数中，在参数列表后以冒号开头，逗号进行分隔的一系列初始化字段。

**为什么用成员初始化列表会快一些（性能优势）？**

使用成员初始化列表执行的是直接初始化的操作，直接使用传入的参数初始化成员对象，省去了执行一次默认构造函数的时间，否则会调用一次传入参数的默认构造函数。所以使用成员初始化列表效率会高一些

有些情况下必须使用成员初始化列表：

* 引用成员的初始化。
* 常量成员的初始化。
* 没有默认构造函数的初始化。

### C++的调用惯例（简单一点C++函数调用的压栈过程）



### C++的四种强制转换

* static_cast：

* dynamic_cast：用于**父类指针和子类指针**之间，**父类引用和子类引用**之间的类型转换。若目标指针并非父类的子类，则会返回空，它是通过运行时类型推断实现的。

* const_cast：用于

* reinterpret_cast：和C

C++中将临时变量作为返回值的时候的处理过程（栈上的内存分配、拷贝过程）

C++的异常处理

volatile关键字

优化程序的几种方法

### public，protected和private访问权限和继承



### inline和宏定义的区别



### C++和C的类型安全



### C++从源文件到可执行文件的过程

从源文件到目标文件的过程为：预编译、编译、汇编、链接。

* 预处理：根据#字符修改原始程序。
* 编译：生成汇编语言程序。
* 汇编：根据汇编语言程序生成可重定位目标文件。
* 链接：把目标文件链接起来生成可执行目标文件。

